// Copyright (c) 2023 Volvo Car Corporation
// SPDX-License-Identifier: Apache-2.0

// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package nats

// // validate the struct implements the interface
// var _ kube.Exporter = (*Surveyor)(nil)
//
// const (
// 	surveyor        = "surveyor"
// 	surveyorVersion = "0.5.0"
// 	// version          = "2.9.16"
//
// 	ImgSurveyor      = "natsio/nats-surveyor:" + surveyorVersion // + version
// 	portNats         = 4222
// 	portSurveyor     = 7777
// 	portNameSurveyor = "http"
// 	SurveyorReplicas = 1
// )
//
// var surveyorMatchLabels = map[string]string{
// 	ku.AppLabelName:     surveyor,
// 	ku.AppLabelInstance: surveyor,
// }
//
// func SurveyorBaseLabels() map[string]string {
// 	return ku.MergeLabels(
// 		surveyorMatchLabels, map[string]string{
// 			"app":                surveyor,
// 			ku.AppLabelComponent: "monitor",
// 			ku.AppLabelPartOf:    namespace,
// 			ku.AppLabelVersion:   surveyorVersion,
// 			ku.AppLabelManagedBy: "lingon",
// 		},
// 	)
// }
//
// // Surveyor contains kubernetes manifests
// type Surveyor struct {
// 	kube.App
//
// 	Deploy *appsv1.Deployment
// 	SA     *corev1.ServiceAccount
// 	SVC    *corev1.Service
// 	SM     *v1.ServiceMonitor
// }
//
// // New creates a new Surveyor
// func NewSurveyor() *Surveyor {
// 	sa := ku.ServiceAccount(surveyor, namespace, BaseLabels(), nil)
//
// 	return &Surveyor{
// 		SA: sa,
//
// 		SM: SurveyorServiceMonitor,
//
// 		Deploy: &appsv1.Deployment{
// 			TypeMeta: ku.TypeDeploymentV1,
// 			ObjectMeta: metav1.ObjectMeta{
// 				Labels:    SurveyorBaseLabels(),
// 				Name:      surveyor,
// 				Namespace: namespace,
// 			},
// 			Spec: appsv1.DeploymentSpec{
// 				Replicas: P(int32(SurveyorReplicas)),
// 				Selector: &metav1.LabelSelector{MatchLabels: surveyorMatchLabels},
// 				Template: corev1.PodTemplateSpec{
// 					ObjectMeta: metav1.ObjectMeta{Labels: surveyorMatchLabels},
// 					Spec: corev1.PodSpec{
// 						ServiceAccountName: sa.Name,
// 						Containers: []corev1.Container{
// 							{
// 								Name:  surveyor,
// 								Image: ImgSurveyor,
// 								Args: []string{
// 									"-p",
// 									fmt.Sprintf("%d", portSurveyor),
// 									fmt.Sprintf(
// 										"-s=nats://nats.nats.svc.cluster.local:%d",
// 										portNats,
// 									),
// 									"--timeout=3s",
// 									"-c=1",
// 								},
// 								ImagePullPolicy: corev1.PullIfNotPresent,
// 								LivenessProbe:   surveyorProbe,
// 								Ports: []corev1.ContainerPort{
// 									{
// 										ContainerPort: int32(portSurveyor),
// 										Name:          portNameSurveyor,
// 										Protocol:      corev1.ProtocolTCP,
// 									},
// 								},
// 								Resources: ku.Resources("2", "4Gi", "2", "4Gi"),
// 							},
// 						},
// 					},
// 				},
// 			},
// 		},
//
// 		SVC: &corev1.Service{
// 			TypeMeta: ku.TypeServiceV1,
// 			ObjectMeta: metav1.ObjectMeta{
// 				Labels:    SurveyorBaseLabels(),
// 				Name:      surveyor,
// 				Namespace: namespace,
// 			},
// 			Spec: corev1.ServiceSpec{
// 				Ports: []corev1.ServicePort{
// 					{
// 						Name:       portNameSurveyor,
// 						Port:       int32(portSurveyor),
// 						Protocol:   corev1.ProtocolTCP,
// 						TargetPort: intstr.FromString(portNameSurveyor),
// 					},
// 				},
// 				Selector: surveyorMatchLabels,
// 				Type:     corev1.ServiceTypeClusterIP,
// 			},
// 		},
// 	}
// }
//
// var surveyorProbe = &corev1.Probe{
// 	FailureThreshold:    int32(3),
// 	InitialDelaySeconds: int32(10),
// 	PeriodSeconds:       int32(30),
// 	ProbeHandler: corev1.ProbeHandler{
// 		HTTPGet: &corev1.HTTPGetAction{
// 			Path: "/healthz",
// 			Port: intstr.FromString(portNameSurveyor),
// 		},
// 	},
// 	SuccessThreshold: int32(1),
// 	TimeoutSeconds:   int32(5),
// }
//
// var SurveyorServiceMonitor = &v1.ServiceMonitor{
// 	ObjectMeta: metav1.ObjectMeta{
// 		Name:      surveyor,
// 		Namespace: monitoring.Namespace,
// 		Labels:    SurveyorBaseLabels(),
// 	},
// 	Spec: v1.ServiceMonitorSpec{
// 		Endpoints: []v1.Endpoint{
// 			{Path: ku.PathMetrics, Port: fmt.Sprintf("%d", portSurveyor)},
// 		},
// 		NamespaceSelector: v1.NamespaceSelector{Any: true},
// 		Selector:          metav1.LabelSelector{MatchLabels: surveyorMatchLabels},
// 	},
// 	TypeMeta: metav1.TypeMeta{
// 		APIVersion: "monitoring.coreos.com/v1",
// 		Kind:       "ServiceMonitor",
// 	},
// }
//
// // Apply applies the kubernetes objects to the cluster
// func (a *Surveyor) Apply(ctx context.Context) error {
// 	return Apply(ctx, a)
// }
//
// // Export exports the kubernetes objects to YAML files in the given directory
// func (a *Surveyor) Export(dir string) error {
// 	return kube.Export(a, kube.WithExportOutputDirectory(dir))
// }

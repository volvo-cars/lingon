// Copyright (c) 2023 Volvo Car Corporation
// SPDX-License-Identifier: Apache-2.0

// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package surveyor

import (
	"context"
	"errors"
	"fmt"
	"os"
	"os/exec"

	v1 "github.com/prometheus-operator/prometheus-operator/pkg/apis/monitoring/v1"
	"github.com/volvo-cars/lingoneks/pkg/platform/monitoring"

	"github.com/volvo-cars/lingon/pkg/kube"
	ku "github.com/volvo-cars/lingon/pkg/kubeutil"
	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/intstr"
)

// validate the struct implements the interface
var _ kube.Exporter = (*Surveyor)(nil)

const (
	appName          = "surveyor"
	namespace        = "nats"
	version          = "0.5.0"
	ImgSurveyor      = "natsio/nats-surveyor:" + version
	portNats         = 4222
	portSurveyor     = 7777
	portNameSurveyor = "http"
	replicas         = 1
)

var (
	SA = ku.ServiceAccount(appName, namespace, BaseLabels(), nil)

	matchLabels = map[string]string{
		ku.AppLabelName:     appName,
		ku.AppLabelInstance: appName,
	}
)

func BaseLabels() map[string]string {
	return ku.MergeLabels(
		matchLabels, map[string]string{
			"app":                appName,
			ku.AppLabelComponent: "monitor",
			ku.AppLabelPartOf:    namespace,
			ku.AppLabelVersion:   version,
			ku.AppLabelManagedBy: "lingon",
		},
	)
}

// Surveyor contains kubernetes manifests
type Surveyor struct {
	kube.App

	Deploy *appsv1.Deployment
	SA     *corev1.ServiceAccount
	SVC    *corev1.Service
	SM     *v1.ServiceMonitor
}

// New creates a new Surveyor
func New() *Surveyor {
	return &Surveyor{
		Deploy: Deploy,
		SA:     SA,
		SVC: &corev1.Service{
			TypeMeta: ku.TypeServiceV1,
			ObjectMeta: metav1.ObjectMeta{
				Labels:    BaseLabels(),
				Name:      appName,
				Namespace: namespace,
			},
			Spec: corev1.ServiceSpec{
				Ports: []corev1.ServicePort{
					{
						Name:       portNameSurveyor,
						Port:       int32(portSurveyor),
						Protocol:   corev1.ProtocolTCP,
						TargetPort: intstr.FromString(portNameSurveyor),
					},
				},
				Selector: matchLabels,
				Type:     corev1.ServiceTypeClusterIP,
			},
		},
		SM: ServiceMonitor,
	}
}

var Deploy = &appsv1.Deployment{
	TypeMeta: ku.TypeDeploymentV1,
	ObjectMeta: metav1.ObjectMeta{
		Labels:    BaseLabels(),
		Name:      appName,
		Namespace: namespace,
	},
	Spec: appsv1.DeploymentSpec{
		Replicas: P(int32(replicas)),
		Selector: &metav1.LabelSelector{MatchLabels: matchLabels},
		Template: corev1.PodTemplateSpec{
			ObjectMeta: metav1.ObjectMeta{Labels: matchLabels},
			Spec: corev1.PodSpec{
				ServiceAccountName: SA.Name,
				Containers: []corev1.Container{
					{
						Name:  appName,
						Image: ImgSurveyor,
						Args: []string{
							"-p",
							fmt.Sprintf("%d", portSurveyor),
							fmt.Sprintf("-s=nats://nats.nats.svc.cluster.local:%d", portNats),
							"--timeout=3s",
							"-c=1",
						},
						ImagePullPolicy: corev1.PullIfNotPresent,
						LivenessProbe: &corev1.Probe{
							ProbeHandler: corev1.ProbeHandler{
								HTTPGet: &corev1.HTTPGetAction{
									Path: "/healthz",
									Port: intstr.FromString(portNameSurveyor),
								},
							},
						},
						Ports: []corev1.ContainerPort{
							{
								ContainerPort: int32(portSurveyor),
								Name:          portNameSurveyor,
								Protocol:      corev1.ProtocolTCP,
							},
						},
						Resources: ku.Resources("2", "4Gi", "2", "4Gi"),
					},
				},
			},
		},
	},
}

var ServiceMonitor = &v1.ServiceMonitor{
	ObjectMeta: metav1.ObjectMeta{
		Name:      appName,
		Namespace: monitoring.Namespace,
		Labels:    BaseLabels(),
	},
	Spec: v1.ServiceMonitorSpec{
		Endpoints: []v1.Endpoint{
			{
				Path: ku.PathMetrics,
				Port: fmt.Sprintf("%d", portSurveyor),
			},
		},
		NamespaceSelector: v1.NamespaceSelector{Any: true},
		Selector: metav1.LabelSelector{
			MatchLabels: matchLabels,
		},
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "monitoring.coreos.com/v1",
		Kind:       "ServiceMonitor",
	},
}

// Apply applies the kubernetes objects to the cluster
func (a *Surveyor) Apply(ctx context.Context) error {
	return Apply(ctx, a)
}

// Export exports the kubernetes objects to YAML files in the given directory
func (a *Surveyor) Export(dir string) error {
	return kube.Export(a, kube.WithExportOutputDirectory(dir))
}

// Apply applies the kubernetes objects contained in Exporter to the cluster
func Apply(ctx context.Context, km kube.Exporter) error {
	cmd := exec.CommandContext(ctx, "kubectl", "apply", "-f", "-")
	cmd.Env = os.Environ()        // inherit environment in case we need to use kubectl from a container
	stdin, err := cmd.StdinPipe() // pipe to pass data to kubectl
	if err != nil {
		return err
	}

	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	go func() {
		defer func() {
			err = errors.Join(err, stdin.Close())
		}()
		if errEW := kube.Export(
			km,
			kube.WithExportWriter(stdin),
			kube.WithExportAsSingleFile("stdin"),
		); errEW != nil {
			err = errors.Join(err, errEW)
		}
	}()

	if errS := cmd.Start(); errS != nil {
		return errors.Join(err, errS)
	}

	// waits for the command to exit and waits for any copying
	// to stdin or copying from stdout or stderr to complete
	return errors.Join(err, cmd.Wait())
}

// P converts T to *T, useful for basic types
func P[T any](t T) *T {
	return &t
}

// Copyright (c) 2023 Volvo Car Corporation
// SPDX-License-Identifier: Apache-2.0

// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package benthos

import (
	"context"
	"errors"
	"fmt"
	"os"
	"os/exec"

	"github.com/volvo-cars/lingoneks/pkg/platform/monitoring"

	promoperatorv1 "github.com/prometheus-operator/prometheus-operator/pkg/apis/monitoring/v1"
	"github.com/volvo-cars/lingon/pkg/kube"
	ku "github.com/volvo-cars/lingon/pkg/kubeutil"
	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/intstr"
)

// validate the struct implements the interface
var _ kube.Exporter = (*Benthos)(nil)

const (
	appName               = "benthos"
	namespace             = "benthos" // TODO: could be in the same namespace as nats
	version               = "4.11.0"
	ImgBenthos            = "jeffail/benthos:" + version
	port                  = 4195
	portName              = "http"
	benthosConfigBasePath = "/etc/benthos-config"
	benthosConfigFile     = "benthos.yaml"
	benthosConfigPath     = benthosConfigBasePath + "/" + benthosConfigFile
)

var (
	SA = ku.ServiceAccount(appName, namespace, BaseLabels(), nil)

	matchLabels = map[string]string{
		ku.AppLabelName:     appName,
		ku.AppLabelInstance: appName,
	}
)

func BaseLabels() map[string]string {
	return ku.MergeLabels(
		matchLabels, map[string]string{
			"app":                appName,
			ku.AppLabelComponent: appName,
			ku.AppLabelPartOf:    appName,
			ku.AppLabelVersion:   version,
			ku.AppLabelManagedBy: "lingon",
		},
	)
}

// Benthos contains kubernetes manifests
type Benthos struct {
	kube.App

	NS                *corev1.Namespace
	ConfigCM          *corev1.ConfigMap
	Deploy            *appsv1.Deployment
	SA                *corev1.ServiceAccount
	SVC               *corev1.Service
	PodConnectionTest *corev1.Pod
	ServiceMonitor    *promoperatorv1.ServiceMonitor
}

// New creates a new Benthos
func New() *Benthos {
	return &Benthos{
		NS:                ku.Namespace(appName, BaseLabels(), nil),
		SA:                SA,
		ServiceMonitor:    ServiceMonitor,
		ConfigCM:          benthosCM.ConfigMap(),
		PodConnectionTest: BenthosPodConnectionTest,

		Deploy: Deploy,

		SVC: &corev1.Service{
			TypeMeta: ku.TypeServiceV1,
			ObjectMeta: metav1.ObjectMeta{
				Labels:    BaseLabels(),
				Name:      appName,
				Namespace: namespace,
			},
			Spec: corev1.ServiceSpec{
				Selector: matchLabels,
				Type:     corev1.ServiceTypeClusterIP,
				Ports: []corev1.ServicePort{
					{
						Name:       portName,
						Port:       int32(80),
						Protocol:   corev1.ProtocolTCP,
						TargetPort: intstr.FromString(portName),
					},
				},
			},
		},
	}
}

// TODO template config

// benthosConfig is a config for Benthos,
// it can be generated with `benthos create "in/pipe/out"`.
var benthosConfig = map[string]string{
	benthosConfigFile: `
input:
  generate:
    interval: 1s
    mapping: |
      root.id = uuid_v4()
output:
  nats:
    urls:
      - nats://nats-0.nats.nats.svc.cluster.local:4222
    subject: demo
metrics:
  prometheus: {}
`,
	"benthos2.yaml": `
http:
  enabled: true
  address: 0.0.0.0:4195
  root_path: /benthos
  debug_endpoints: true
  cors:
    enabled: true
input:
  label: "no_config_in"
  generate:
    mapping: root = "This Benthos instance is unconfigured!"
    interval: 1m
buffer:
  none: {}
pipeline:
  threads: -1
  processors: []
output:
  label: "no_config_out"
  stdout:
    codec: lines
metrics:
  prometheus:
    use_histogram_timing: false
    histogram_buckets: []
    add_process_metrics: true
    add_go_metrics: true
    push_url: ""
    push_interval: ""
    push_job_name: benthos_push
    push_basic_auth:
      username: ""
      password: ""
    file_output_path: ""
  mapping: ""
shutdown_delay: ""
shutdown_timeout: 20s
`,
}

var benthosCM = ku.ConfigAndMount{
	Data: benthosConfig,
	ObjectMeta: metav1.ObjectMeta{
		Labels:    BaseLabels(),
		Name:      "benthos-config",
		Namespace: namespace,
	},
	VolumeMount: corev1.VolumeMount{
		Name:      "config-volume",
		MountPath: benthosConfigBasePath,
	},
}

var BenthosPodConnectionTest = &corev1.Pod{
	ObjectMeta: metav1.ObjectMeta{
		Annotations: map[string]string{
			"helm.sh/hook":              "test",
			"kube-linter.io/ignore-all": "Linter does not need to run on this test",
		},
		Labels:    BaseLabels(),
		Name:      "benthos-test-connection",
		Namespace: namespace,
	},
	Spec: corev1.PodSpec{
		Containers: []corev1.Container{
			{
				Args:    []string{fmt.Sprintf("benthos:%d/ping", port)},
				Command: []string{"wget"},
				Image:   "busybox",
				Name:    "wget",
			},
		},
		RestartPolicy: corev1.RestartPolicyNever,
	},
	TypeMeta: ku.TypePodV1,
}

var Deploy = &appsv1.Deployment{
	TypeMeta: ku.TypeDeploymentV1,
	ObjectMeta: metav1.ObjectMeta{
		Labels:    BaseLabels(),
		Name:      appName,
		Namespace: namespace,
	},
	Spec: appsv1.DeploymentSpec{
		Replicas: P(int32(1)),
		Selector: &metav1.LabelSelector{MatchLabels: matchLabels},
		Template: corev1.PodTemplateSpec{
			ObjectMeta: metav1.ObjectMeta{Labels: matchLabels},
			Spec: corev1.PodSpec{
				ServiceAccountName: SA.Name,
				Containers: []corev1.Container{
					{
						Name:            appName,
						Image:           ImgBenthos,
						Args:            []string{"-c", benthosConfigPath},
						Env:             []corev1.EnvVar{benthosCM.HashEnv("CONFIG_HASH_ENV")},
						ImagePullPolicy: corev1.PullIfNotPresent,
						Ports:           []corev1.ContainerPort{containerPort(port)},
						LivenessProbe:   probe("/ping"),
						ReadinessProbe:  probe("/ready"),
						Resources:       ku.Resources("2", "4Gi", "2", "4Gi"),
						VolumeMounts:    []corev1.VolumeMount{benthosCM.VolumeMount},
					},
				},
				Volumes: []corev1.Volume{benthosCM.VolumeAndMount().Volume()},
			},
		},
	},
}

func containerPort(port int) corev1.ContainerPort {
	return corev1.ContainerPort{
		Name:          portName,
		ContainerPort: int32(port),
		Protocol:      corev1.ProtocolTCP,
	}
}

func probe(path string) *corev1.Probe {
	return &corev1.Probe{
		ProbeHandler: corev1.ProbeHandler{
			HTTPGet: &corev1.HTTPGetAction{
				Path: path,
				Port: intstr.FromString(portName),
			},
		},
	}
}

var ServiceMonitor = &promoperatorv1.ServiceMonitor{
	ObjectMeta: metav1.ObjectMeta{
		Name:      appName,
		Namespace: monitoring.Namespace,
		Labels:    BaseLabels(),
	},
	Spec: promoperatorv1.ServiceMonitorSpec{
		Endpoints: []promoperatorv1.Endpoint{
			{
				Path: ku.PathMetrics,
				Port: portName,
			},
		},
		NamespaceSelector: promoperatorv1.NamespaceSelector{Any: true},
		Selector: metav1.LabelSelector{
			MatchLabels: matchLabels,
		},
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "monitoring.coreos.com/v1",
		Kind:       "ServiceMonitor",
	},
}

// Apply applies the kubernetes objects to the cluster
func (a *Benthos) Apply(ctx context.Context) error {
	return Apply(ctx, a)
}

// Export exports the kubernetes objects to YAML files in the given directory
func (a *Benthos) Export(dir string) error {
	return kube.Export(a, kube.WithExportOutputDirectory(dir))
}

// Apply applies the kubernetes objects contained in Exporter to the cluster
func Apply(ctx context.Context, km kube.Exporter) error {
	cmd := exec.CommandContext(ctx, "kubectl", "apply", "-f", "-")
	cmd.Env = os.Environ()        // inherit environment in case we need to use kubectl from a container
	stdin, err := cmd.StdinPipe() // pipe to pass data to kubectl
	if err != nil {
		return err
	}

	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	go func() {
		defer func() {
			err = errors.Join(err, stdin.Close())
		}()
		if errEW := kube.Export(
			km,
			kube.WithExportWriter(stdin),
			kube.WithExportAsSingleFile("stdin"),
		); errEW != nil {
			err = errors.Join(err, errEW)
		}
	}()

	if errS := cmd.Start(); errS != nil {
		return errors.Join(err, errS)
	}

	// waits for the command to exit and waits for any copying
	// to stdin or copying from stdout or stderr to complete
	return errors.Join(err, cmd.Wait())
}

// P converts T to *T, useful for basic types
func P[T any](t T) *T {
	return &t
}

// Copyright (c) 2023 Volvo Car Corporation
// SPDX-License-Identifier: Apache-2.0

// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package metricsserver

import (
	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/intstr"
)

var Deploy = &appsv1.Deployment{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance":   "metrics-server",
			"app.kubernetes.io/managed-by": "Helm",
			"app.kubernetes.io/name":       "metrics-server",
			"app.kubernetes.io/version":    "0.6.3",
			"helm.sh/chart":                "metrics-server-3.10.0",
		},
		Name:      "metrics-server",
		Namespace: namespace,
	},
	Spec: appsv1.DeploymentSpec{
		Replicas: P(int32(1)),
		Selector: &metav1.LabelSelector{
			MatchLabels: map[string]string{
				"app.kubernetes.io/instance": "metrics-server",
				"app.kubernetes.io/name":     "metrics-server",
			},
		},
		Strategy: appsv1.DeploymentStrategy{
			RollingUpdate: &appsv1.RollingUpdateDeployment{MaxUnavailable: &intstr.IntOrString{IntVal: int32(1)}},
			Type:          appsv1.DeploymentStrategyType("RollingUpdate"),
		},
		Template: corev1.PodTemplateSpec{
			ObjectMeta: metav1.ObjectMeta{
				Labels: map[string]string{
					"app.kubernetes.io/instance": "metrics-server",
					"app.kubernetes.io/name":     "metrics-server",
				},
			},
			Spec: corev1.PodSpec{
				Affinity: &corev1.Affinity{
					PodAntiAffinity: &corev1.PodAntiAffinity{
						PreferredDuringSchedulingIgnoredDuringExecution: []corev1.WeightedPodAffinityTerm{
							{
								PodAffinityTerm: corev1.PodAffinityTerm{
									LabelSelector: &metav1.LabelSelector{
										MatchLabels: map[string]string{
											"app.kubernetes.io/instance": "metrics-server",
											"app.kubernetes.io/name":     "metrics-server",
										},
									},
									TopologyKey: "kubernetes.io/hostname",
								},
								Weight: int32(1),
							},
						},
					},
				},
				Containers: []corev1.Container{
					{
						Args: []string{
							"--secure-port=10250",
							"--cert-dir=/tmp",
							"--kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname",
							"--kubelet-use-node-status-port",
							"--metric-resolution=15s",
							"--authorization-always-allow-paths=/metrics",
						},
						Image:           "registry.k8s.io/metrics-server/metrics-server:v0.6.3",
						ImagePullPolicy: corev1.PullPolicy("IfNotPresent"),
						LivenessProbe: &corev1.Probe{
							FailureThreshold: int32(3),
							PeriodSeconds:    int32(10),
							ProbeHandler: corev1.ProbeHandler{
								HTTPGet: &corev1.HTTPGetAction{
									Path: "/livez",
									Port: intstr.IntOrString{
										StrVal: "https",
										Type:   intstr.Type(int64(1)),
									},
									Scheme: corev1.URIScheme("HTTPS"),
								},
							},
						},
						Name: "metrics-server",
						Ports: []corev1.ContainerPort{
							{
								ContainerPort: int32(10250),
								Name:          "https",
								Protocol:      corev1.Protocol("TCP"),
							},
						},
						ReadinessProbe: &corev1.Probe{
							FailureThreshold:    int32(3),
							InitialDelaySeconds: int32(20),
							PeriodSeconds:       int32(10),
							ProbeHandler: corev1.ProbeHandler{
								HTTPGet: &corev1.HTTPGetAction{
									Path: "/readyz",
									Port: intstr.IntOrString{
										StrVal: "https",
										Type:   intstr.Type(int64(1)),
									},
									Scheme: corev1.URIScheme("HTTPS"),
								},
							},
						},
						SecurityContext: &corev1.SecurityContext{
							Capabilities:           &corev1.Capabilities{Drop: []corev1.Capability{corev1.Capability("ALL")}},
							ReadOnlyRootFilesystem: P(true),
							RunAsNonRoot:           P(true),
							RunAsUser:              P(int64(1000)),
							SeccompProfile:         &corev1.SeccompProfile{Type: corev1.SeccompProfileType("RuntimeDefault")},
						},
						VolumeMounts: []corev1.VolumeMount{
							{
								MountPath: "/tmp",
								Name:      "tmp",
							},
						},
					},
				},
				PriorityClassName:  "system-cluster-critical",
				ServiceAccountName: "metrics-server",
				Volumes: []corev1.Volume{
					{
						Name:         "tmp",
						VolumeSource: corev1.VolumeSource{},
					},
				},
			},
		},
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "apps/v1",
		Kind:       "Deployment",
	},
}

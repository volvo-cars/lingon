// Copyright 2023 Volvo Car Corporation
// SPDX-License-Identifier: Apache-2.0

package kube

import (
	"bytes"
	"fmt"
	"path/filepath"
	"reflect"
	"strconv"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/volvo-cars/lingon/pkg/internal/api"
	"github.com/volvo-cars/lingon/pkg/kubeutil"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/runtime"
)

var headerComment = "Code generated by lingon. EDIT AS MUCH AS YOU LIKE."

// jamel is short for Jennifer and YAML.
// It is used to generate Go code from Kubernetes manifests.
// Not meant to be created directly, use newImporter(opts...) instead.
type jamel struct {
	objectsCode       map[string]*jen.Statement    // obj name => obj as Go struct
	kubeAppStructCode map[string]*jen.Statement    // fieldName => fieldType
	objectsMeta       map[string]kubeutil.Metadata // obj name => obj meta
	// nameFieldVar maps object name to object variable name
	nameFieldVar map[string]string
	o            option       // options
	buf          bytes.Buffer // buffer to write the generated code to
	useReader    bool         // if true, read from io.Reader
	useWriter    bool         // if true, write to io.Writer
}

func Import(opts ...ImportOption) error {
	j := newImporter(opts...)
	if j.useWriter {
		return j.render()
	}
	if err := j.save(); err != nil {
		return fmt.Errorf("convert to Go: %w", err)
	}
	return nil
}

func newImporter(
	opts ...ImportOption,
) *jamel {
	j := &jamel{
		useReader:         false,
		useWriter:         false,
		objectsCode:       make(map[string]*jen.Statement),
		kubeAppStructCode: make(map[string]*jen.Statement),
		objectsMeta:       make(map[string]kubeutil.Metadata),
		nameFieldVar:      make(map[string]string),
		o:                 defaultOpts,
	}
	// options
	for _, opt := range opts {
		opt(j)
	}

	gatekeeperOptions(&j.o)

	return j
}

func gatekeeperOptions(o *option) {
	if len(o.OutputPkgName) == 0 {
		o.OutputPkgName = strings.ReplaceAll(o.AppName, "-", "")
	}
	if strings.Contains(o.OutputPkgName, "-") {
		panic("package name cannot contain a dash")
	}
}

func (j *jamel) generateGo() error {
	if j.useReader {
		splitYaml, err := splitManifest(j.o.ManifestReader)
		if err != nil {
			return err
		}
		if len(splitYaml) == 0 {
			return fmt.Errorf("no manifest found")
		}
		err = j.convertToGo(splitYaml)
		if err != nil {
			return fmt.Errorf("stdin: %w", err)
		}
		return nil
	}

	for _, filePath := range j.o.ManifestFiles {
		splitYaml, err := ReadManifest(filePath)
		if err != nil {
			return err
		}

		err = j.convertToGo(splitYaml)
		if err != nil {
			return fmt.Errorf("file %s: %w", filePath, err)
		}
	}

	return nil
}

func (j *jamel) convertToGo(splitYaml []string) error {
	vcpt := 1 // variable name counter to avoid name collisions
	scpt := 1 // struct field name counter to avoid name collisions
	for _, y := range splitYaml {
		data := []byte(y)
		m, err := kubeutil.ExtractMetadata(data)
		if err != nil {
			return fmt.Errorf("extract metadata: %w", err)
		}

		//
		// convert kubernetes objects to generated Go code
		//
		jenCode, err := j.yaml2GoJen(data, m)
		if err != nil {
			return err
		}

		nameVar := j.o.NameVarFunc(*m)
		if j.o.RemoveAppName {
			nameVar = RemoveAppName(nameVar, j.o.AppName)
		}
		// check for duplicate
		if _, ok := j.objectsCode[nameVar]; ok {
			nameVar += strconv.Itoa(vcpt)
			vcpt++
		}
		j.objectsCode[nameVar] = jenCode

		//
		// kube.App struct
		//
		nameField := j.o.NameFieldFunc(*m)
		if j.o.RemoveAppName {
			nameField = RemoveAppName(nameField, j.o.AppName)
		}
		// check for duplicate
		if _, ok := j.kubeAppStructCode[nameField]; ok {
			nameField += strconv.Itoa(scpt)
			scpt++
		}

		pkgPath, err := api.PkgPathFromAPIVersion(m.APIVersion)
		if err != nil {
			pkgPath = m.APIVersion
		}

		structFieldType := jen.Qual(pkgPath, m.Kind)
		j.kubeAppStructCode[nameField] = structFieldType

		// nameFieldVar is used to map the name of the object to the variable name
		j.nameFieldVar[nameField] = nameVar
		// objectsMeta maps the name of the variable to the Metadata
		j.objectsMeta[nameVar] = *m

		// hack: reset counters if too high
		if vcpt >= 10 || scpt >= 10 {
			vcpt = 1
			scpt = 1
		}

	}
	return nil
}

func (j *jamel) yaml2GoJen(data []byte, m *kubeutil.Metadata) (
	*jen.Statement,
	error,
) {
	decoded, _, err := j.o.Serializer.Decode(data, nil, nil)
	if err != nil {
		return nil, fmt.Errorf("decoding manifest: %w", err)
	}

	var jenCode *jen.Statement
	switch m.Kind {
	case "ConfigMap":
		// special case for ConfigMap
		// we want to extract the comments from the YAML
		cm, ok := decoded.(*corev1.ConfigMap)
		if !ok {
			return nil, fmt.Errorf("expected ConfigMap, got %T", decoded)
		}
		jenCode, err = j.configMapComment(cm, data)
		if err != nil {
			return nil, fmt.Errorf("configmap comment: %w", err)
		}
	default:
		jenCode = j.kube2GoJen(decoded)
	}
	return jenCode, nil
}

func (j *jamel) kube2GoJen(obj runtime.Object) *jen.Statement {
	rv := reflect.ValueOf(obj)
	return j.convertValue(rv)
}

func (j *jamel) addManifest(filePath string) error {
	filename := filepath.Base(filePath)
	e := filepath.Ext(filename)
	if e != ".yaml" && e != ".yml" {
		return fmt.Errorf("not yaml file: %s", filePath)
	}

	if !fileExists(filePath) {
		return fmt.Errorf("file does not exist: %s", filePath)
	}
	j.o.ManifestFiles = append(j.o.ManifestFiles, filePath)
	return nil
}

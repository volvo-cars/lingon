// Copyright (c) Volvo Car AB
// SPDX-License-Identifier: Apache-2.0

package kube

import (
	"fmt"
	"path/filepath"
	"reflect"
	"strconv"

	"github.com/dave/jennifer/jen"
	"github.com/volvo-cars/lingon/pkg/internal/api"
	"github.com/volvo-cars/lingon/pkg/kubeutil"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/runtime"
)

var headerComment = "Code generated by lingon. EDIT AS MUCH AS YOU LIKE."

// jamel is short for Jennifer and YAML
// It is used to generate Go code from Kubernetes manifests
// Not meant to be created directly, use newImporter(opts...) instead.
type jamel struct {
	objectsCode       map[string]*jen.Statement    // obj name => obj as Go struct
	kubeAppStructCode map[string]*jen.Statement    // fieldName => fieldType
	objectsMeta       map[string]kubeutil.Metadata // obj name => obj meta
	// nameFieldVar maps object name to object variable name
	nameFieldVar map[string]string
	o            Option // options
	useReader    bool   // if true, read from io.Reader
	useWriter    bool   // if true, write to io.Writer
}

func Import(opts ...ImportOption) error {
	j := newImporter(opts...)
	if j.useWriter {
		return j.render()
	}
	if err := j.save(); err != nil {
		return fmt.Errorf("convert to Go: %w", err)
	}
	return nil
}

func newImporter(
	opts ...ImportOption,
) *jamel {
	j := &jamel{
		useReader:         false,
		objectsCode:       make(map[string]*jen.Statement),
		kubeAppStructCode: make(map[string]*jen.Statement),
		objectsMeta:       make(map[string]kubeutil.Metadata),
		nameFieldVar:      make(map[string]string),
		o:                 defaultOpts,
	}
	// options
	for _, opt := range opts {
		opt(j)
	}
	// if !filepath.IsAbs(j.o.OutputDir) {
	// 	cwd, err := os.Getwd()
	// 	if err != nil {
	// 		panic(err)
	// 	}
	// 	j.o.OutputDir = filepath.Join(cwd, j.o.OutputDir)
	// }

	return j
}

func (j *jamel) kube2GoJen(obj runtime.Object) *jen.Statement {
	rv := reflect.ValueOf(obj)
	return j.convertValue(rv)
}

func (j *jamel) generate(splitYaml []string) error {
	vcpt := 1 // variable name counter to avoid name collisions
	scpt := 1 // struct field name counter to avoid name collisions
	for _, y := range splitYaml {
		data := []byte(y)
		m, err := kubeutil.ExtractMetadata(data)
		if err != nil {
			return fmt.Errorf("extract metadata: %w", err)
		}

		//
		// CONVERT K8S RESOURCES TO GO
		//
		jenCode, err := j.yaml2GoJen(data, m)
		if err != nil {
			return err
		}

		nameVar := j.o.NameVarFunc(*m)
		if j.o.RemoveAppName {
			nameVar = RemoveAppName(nameVar, j.o.AppName)
		}
		// check for duplicate
		if _, ok := j.objectsCode[nameVar]; ok {
			nameVar += strconv.Itoa(vcpt)
			vcpt++
		}
		j.objectsCode[nameVar] = jenCode

		//
		// KUBEAPP STRUCT
		//
		nameField := j.o.NameFieldFunc(*m)
		if j.o.RemoveAppName {
			nameField = RemoveAppName(nameField, j.o.AppName)
		}
		// check for duplicate
		if _, ok := j.kubeAppStructCode[nameField]; ok {
			nameField += strconv.Itoa(scpt)
			scpt++
		}

		pkgPath, err := api.PkgPathFromAPIVersion(m.APIVersion)
		if err != nil {
			pkgPath = m.APIVersion
		}

		structFieldType := jen.Qual(pkgPath, m.Kind)
		j.kubeAppStructCode[nameField] = structFieldType

		// nameFieldVar is used to map the name of the object to the variable name
		j.nameFieldVar[nameField] = nameVar
		// objectsMeta maps the name of the variable to the Metadata
		j.objectsMeta[nameVar] = *m

		// reset counters if too high
		if vcpt >= 10 || scpt >= 10 {
			vcpt = 1
			scpt = 1
		}

	}
	return nil
}

func (j *jamel) yaml2GoJen(data []byte, m *kubeutil.Metadata) (
	*jen.Statement,
	error,
) {
	decoded, _, err := j.o.Serializer.Decode(data, nil, nil)
	if err != nil {
		return nil, fmt.Errorf("decoding manifest: %w", err)
	}

	var jenCode *jen.Statement
	if m.Kind == "ConfigMap" {
		// special case for ConfigMap
		// we want to extract the comments from the YAML
		cm, ok := decoded.(*corev1.ConfigMap)
		if !ok {
			return nil, fmt.Errorf("expected ConfigMap, got %T", decoded)
		}
		jenCode, err = j.configMapComment(cm, data)
		if err != nil {
			return nil, fmt.Errorf("configmap comment: %w", err)
		}
	} else {
		jenCode = j.kube2GoJen(decoded)
	}
	return jenCode, nil
}

func (j *jamel) generateGo() error {
	if j.useReader {
		splitYaml, err := SplitManifest(j.o.ManifestReader)
		if err != nil {
			return err
		}
		if len(splitYaml) == 0 {
			return fmt.Errorf("no manifest found")
		}
		err = j.generate(splitYaml)
		if err != nil {
			return fmt.Errorf("stdin: %w", err)
		}
		return nil
	}

	for _, filePath := range j.o.ManifestFiles {
		splitYaml, err := ReadManifest(filePath)
		if err != nil {
			return err
		}

		err = j.generate(splitYaml)
		if err != nil {
			return fmt.Errorf("file %s: %w", filePath, err)
		}
	}

	return nil
}

func (j *jamel) addManifest(filePath string) error {
	filename := filepath.Base(filePath)
	e := filepath.Ext(filename)
	if e != ".yaml" && e != ".yml" {
		return fmt.Errorf("not yaml file: %s", filePath)
	}

	if !fileExists(filePath) {
		return fmt.Errorf("file does not exist: %s", filePath)
	}
	j.o.ManifestFiles = append(j.o.ManifestFiles, filePath)
	return nil
}
